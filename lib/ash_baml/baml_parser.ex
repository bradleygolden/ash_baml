defmodule AshBaml.BamlParser do
  @moduledoc """
  Parses BAML schemas and extracts type information for code generation.

  This module wraps the baml_elixir parsing functionality to provide
  a clean interface for extracting classes, enums, and functions.
  """

  @doc """
  Extracts all type definitions from BAML files in the given path.

  ## Parameters
  - `baml_src_path` - Path to directory containing .baml files

  ## Returns
  - `{:ok, %{classes: map, enums: map, functions: map}}` on success
  - `{:error, reason}` on failure
  """
  def parse_schema(baml_src_path) do
    case BamlElixir.Native.parse_baml(baml_src_path) do
      baml_types when is_map(baml_types) ->
        classes = Map.get(baml_types, :classes, %{})
        enums = Map.get(baml_types, :enums, %{})
        functions = Map.get(baml_types, :functions, %{})

        {:ok, %{classes: classes, enums: enums, functions: functions}}

      error ->
        {:error, "Failed to parse BAML files: #{inspect(error)}"}
    end
  end

  @doc """
  Extracts class definitions from parsed BAML schema.

  Returns a map where keys are class names and values contain field definitions.
  """
  def extract_classes(%{classes: classes}), do: classes

  @doc """
  Extracts enum definitions from parsed BAML schema.

  Returns a map where keys are enum names and values are lists of variants.
  """
  def extract_enums(%{enums: enums}), do: enums

  @doc """
  Gets the BAML source path from a client module's configuration.

  ## Parameters
  - `client_module` - Module that uses BamlElixir.Client

  ## Returns
  - `{:ok, path}` if configuration found
  - `{:error, reason}` if not found

  ## Implementation Notes
  The `__baml_src_path__/0` callback is automatically generated by both:
  - `use BamlElixir.Client` macro (for explicit client modules)
  - `DefineClientModules` transformer (for config-driven clients)

  At compile time, if the module is not yet loaded, this will attempt to
  extract the path from the module's source file as a fallback.
  """
  def get_baml_path(client_module) do
    cond do
      function_exported?(client_module, :__baml_src_path__, 0) ->
        {:ok, client_module.__baml_src_path__()}

      Code.ensure_compiled(client_module) == {:module, client_module} &&
          function_exported?(client_module, :__baml_src_path__, 0) ->
        {:ok, client_module.__baml_src_path__()}

      path = extract_path_from_source(client_module) ->
        {:ok, path}

      true ->
        {:error,
         """
         Client module #{inspect(client_module)} does not implement __baml_src_path__/0.

         For config-driven clients, ensure the module is defined in config:

             config :ash_baml,
               clients: [
                 my_client: {#{inspect(client_module)}, baml_src: "baml_src"}
               ]

         For explicit client modules, use BamlElixir.Client:

             defmodule #{inspect(client_module)} do
               use BamlElixir.Client, path: "baml_src"
             end

         The __baml_src_path__/0 callback will be generated automatically.
         """}
    end
  end

  defp extract_path_from_source(client_module) do
    with module_source_path when not is_nil(module_source_path) <-
           find_module_source(client_module),
         {:ok, source} <- File.read(module_source_path),
         [_, path] <-
           Regex.run(
             ~r/def\s+__baml_src_path__.*?Path\.(?:join|expand)\([^,)]*,?\s*"([^"]+)"\)/s,
             source
           ) do
      path
    else
      _ -> nil
    end
  end

  defp find_module_source(module) do
    source_paths =
      with true <- Code.ensure_loaded?(Mix.Project),
           config <- Mix.Project.config() do
        config[:source_paths] || ["lib"]
      else
        _ -> ["lib"]
      end

    relative_path =
      module
      |> Module.split()
      |> Enum.map(&Macro.underscore/1)
      |> Path.join()
      |> then(&"#{&1}.ex")

    search_paths =
      Enum.flat_map(source_paths, fn source_path ->
        [
          Path.join(source_path, relative_path),
          Path.join([source_path, "support", Path.basename(relative_path)])
        ]
      end)

    Enum.find(search_paths, &File.exists?/1)
  end
end
