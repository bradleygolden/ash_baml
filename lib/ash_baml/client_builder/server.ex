defmodule AshBaml.ClientBuilder.Server do
  @moduledoc false
  use GenServer

  def ensure_module(module_name, baml_src) do
    GenServer.call(__MODULE__, {:ensure_module, module_name, baml_src}, :infinity)
  end

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  @impl GenServer
  def init(_arg), do: {:ok, %{}}

  @impl GenServer
  def handle_call({:ensure_module, module_name, baml_src}, _from, state) do
    case Map.get(state, module_name) do
      :created ->
        {:reply, :ok, state}

      nil ->
        {result, new_state} = ensure_or_create_module(module_name, baml_src, state)
        {:reply, result, new_state}
    end
  end

  defp ensure_or_create_module(module_name, baml_src, state) do
    cond do
      module_loaded_with_same_source?(module_name, baml_src) ->
        {:ok, Map.put(state, module_name, :created)}

      Code.ensure_loaded?(module_name) ->
        {:ok, Map.put(state, module_name, :created)}

      true ->
        result = do_create_module(module_name, baml_src)
        new_state = if result == :ok, do: Map.put(state, module_name, :created), else: state
        {result, new_state}
    end
  end

  defp module_loaded_with_same_source?(module_name, baml_src) do
    Code.ensure_loaded?(module_name) and
      function_exported?(module_name, :__baml_src_path__, 0) and
      module_name.__baml_src_path__() == Path.expand(baml_src, File.cwd!())
  end

  defp do_create_module(module_name, baml_src) do
    {:module, _module, _binary, _result} =
      Module.create(
        module_name,
        quote location: :keep do
          @moduledoc """
          Auto-generated BAML client module.

          Generated by AshBaml from application config.
          Do not modify this module manually.

          BAML source: #{unquote(baml_src)}
          """

          use BamlElixir.Client, path: unquote(baml_src)

          def __baml_src_path__ do
            Path.expand(unquote(baml_src), File.cwd!())
          end
        end,
        Macro.Env.location(__ENV__)
      )

    :ok
  rescue
    e in ArgumentError ->
      handle_argument_error(e, module_name)

    e in CompileError ->
      handle_compile_error(e, module_name)

    e ->
      {:error, "Failed to create BAML client module #{inspect(module_name)}: #{inspect(e)}"}
  end

  defp handle_argument_error(error, module_name) do
    error_message = Exception.message(error)

    if String.contains?(error_message, "cannot define module") and
         String.contains?(error_message, "currently being defined") do
      :ok
    else
      {:error, "Failed to create BAML client module #{inspect(module_name)}: #{inspect(error)}"}
    end
  end

  defp handle_compile_error(error, module_name) do
    if (String.contains?(error.description, "cannot compile module") or
          String.contains?(error.description, "cannot define module")) and
         String.contains?(error.description, "currently being defined") do
      :ok
    else
      {:error, "Failed to create BAML client module #{inspect(module_name)}: #{inspect(error)}"}
    end
  end
end
