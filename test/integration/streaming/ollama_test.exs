defmodule AshBaml.Integration.Streaming.OllamaTest do
  use AshBaml.IntegrationCase, provider: :ollama

  @moduletag timeout: 60_000

  alias Ash.Resource.Info
  alias AshBaml.Test.{AutoGeneratedTestResource, TestResource}
  alias AshBaml.Test.BamlClient.Types, as: BamlClient

  describe "basic streaming functionality" do
    test "stream returns chunks as they arrive" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello and count to 5"
        })
        |> Ash.run_action()

      assert is_function(stream)

      chunks = Enum.to_list(stream)
      assert is_list(chunks)
      assert length(chunks) > 0

      assert Enum.all?(chunks, fn chunk ->
               match?(%BamlClient.Reply{}, chunk)
             end)
    end

    test "stream can be enumerated" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a very short poem"
        })
        |> Ash.run_action()

      {:ok, agent} = Agent.start_link(fn -> [] end)

      on_exit(fn ->
        if Process.alive?(agent), do: Agent.stop(agent)
      end)

      stream
      |> Enum.each(fn chunk ->
        Agent.update(agent, fn chunks -> [chunk | chunks] end)
      end)

      collected_chunks = Agent.get(agent, & &1)
      assert is_list(collected_chunks)
      assert length(collected_chunks) > 0
    end

    test "stream completes with final result" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say 'test complete'"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      assert length(chunks) > 0

      final_chunk = List.last(chunks)
      assert %BamlClient.Reply{} = final_chunk
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
    end

    test "stream can be consumed multiple times" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      first_chunks = Enum.to_list(stream)
      assert length(first_chunks) > 0

      # Note: Streams are typically single-use, but we can get a new one
      {:ok, stream2} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      second_chunks = Enum.to_list(stream2)
      assert length(second_chunks) > 0

      assert Enum.all?(first_chunks, &match?(%BamlClient.Reply{}, &1))
      assert Enum.all?(second_chunks, &match?(%BamlClient.Reply{}, &1))
    end
  end

  describe "stream structure and types" do
    test "stream chunks have correct structure" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Generate a test response"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      assert length(chunks) > 0

      invalid_chunks =
        chunks
        |> Enum.reject(fn chunk ->
          match?(%BamlClient.Reply{content: content} when is_binary(content), chunk)
        end)

      assert invalid_chunks == [], "Found invalid chunks: #{inspect(invalid_chunks)}"

      final_chunk = List.last(chunks)
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
      assert final_chunk.confidence >= 0.0 and final_chunk.confidence <= 1.0
    end

    test "stream returns proper Elixir Stream" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Test"
        })
        |> Ash.run_action()

      assert is_function(stream)

      mapped_stream =
        stream
        |> Stream.map(fn chunk -> chunk.content end)
        |> Stream.filter(fn content -> content != nil and content != "" end)

      assert match?(%Stream{}, mapped_stream)

      contents = Enum.to_list(mapped_stream)
      assert length(contents) > 0
      assert Enum.all?(contents, &is_binary/1)
    end
  end

  describe "auto-generated streaming actions" do
    test "import_functions creates working stream action" do
      actions = Info.actions(AutoGeneratedTestResource)
      stream_action = Enum.find(actions, fn action -> action.name == :test_action_stream end)

      assert stream_action != nil
      assert stream_action.type == :action

      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Test auto-generated action"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0
      assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
    end

    test "stream action arguments match BAML function signature" do
      actions = Info.actions(AutoGeneratedTestResource)
      stream_action = Enum.find(actions, fn action -> action.name == :test_action_stream end)

      arguments = stream_action.arguments
      message_arg = Enum.find(arguments, fn arg -> arg.name == :message end)

      assert message_arg != nil
      assert message_arg.type == Ash.Type.String
      assert message_arg.allow_nil? == false
    end

    test "generated stream action name is correctly snake_cased" do
      actions = Info.actions(AutoGeneratedTestResource)
      action_names = Enum.map(actions, & &1.name)

      assert :test_action_stream in action_names
    end
  end

  describe "stream performance and concurrency" do
    test "stream handles early termination" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a very long story about a dragon"
        })
        |> Ash.run_action()

      first_three = Enum.take(stream, 3)

      assert length(first_three) == 3

      assert Enum.all?(first_three, &match?(%BamlClient.Reply{}, &1))

      # The stream should have been terminated early without errors
      # (no assertion needed - if it doesn't crash, it works)
    end

    test "multiple concurrent streams work correctly" do
      tasks =
        for i <- 1..3 do
          Task.async(fn ->
            {:ok, stream} =
              TestResource
              |> Ash.ActionInput.for_action(:test_action_stream, %{
                message: "Count to #{i}"
              })
              |> Ash.run_action()

            chunks = Enum.to_list(stream)
            {i, chunks}
          end)
        end

      results = Task.await_many(tasks, 30_000)

      assert length(results) == 3

      Enum.each(results, fn {_i, chunks} ->
        assert length(chunks) > 0
        assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
      end)
    end

    test "stream completes in reasonable time" do
      start_time = System.monotonic_time(:millisecond)

      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      _chunks = Enum.to_list(stream)

      end_time = System.monotonic_time(:millisecond)
      duration = end_time - start_time

      assert duration < 10_000
    end
  end

  describe "stream error resilience" do
    @tag :skip
    test "stream handles API errors mid-stream gracefully" do
      # Skipped: Requires mocking to inject errors reliably
      # Current implementation just hopes an error happens naturally
      flunk("Test skipped - requires error injection mocking")
    end

    @tag :skip
    test "stream raises exception on API errors" do
      # This test requires mocking BAML client to inject errors
      # Will be implemented when error injection is available
      # For now, skip to document expected behavior

      # Expected behavior:
      # - API error during streaming should raise exception
      # - Exception should be caught by Task
      # - Caller should receive {:error, exception} tuple
    end
  end

  describe "stream consistency" do
    test "stream final result matches non-streaming result" do
      message = "Say exactly: Hello from BAML"

      # Get non-streaming result
      {:ok, non_stream_response} =
        TestResource
        |> Ash.ActionInput.for_action(:test_function, %{
          message: message
        })
        |> Ash.run_action()

      assert %AshBaml.Response{} = non_stream_response
      non_stream_result = non_stream_response.data

      # Get streaming result
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: message
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      final_chunk = List.last(chunks)

      # Both should be Reply structs
      assert %BamlClient.Reply{} = non_stream_result
      assert %BamlClient.Reply{} = final_chunk

      assert String.contains?(non_stream_result.content, "BAML") or
               String.contains?(non_stream_result.content, "Hello")

      assert String.contains?(final_chunk.content, "BAML") or
               String.contains?(final_chunk.content, "Hello")

      assert non_stream_result.confidence >= 0.0 and non_stream_result.confidence <= 1.0
      assert final_chunk.confidence >= 0.0 and final_chunk.confidence <= 1.0

      assert is_binary(non_stream_result.content)
      assert is_binary(final_chunk.content)
      assert String.length(non_stream_result.content) > 0
      assert String.length(final_chunk.content) > 0
    end
  end

  describe "stream content variations" do
    test "stream with very long response" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a detailed description of how to bake a cake, including all steps"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      assert length(chunks) > 0

      full_content = Enum.map_join(chunks, "", & &1.content)

      assert String.length(full_content) > 50
    end

    test "stream with very short input" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Hi"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert is_list(chunks)
      assert length(chunks) > 0
    end

    test "stream with special characters" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say: Hello! ä½ å¥½ ðŸŒŸ @#$%"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0
      assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
    end

    test "stream with unicode and emoji" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello in Japanese: ã“ã‚“ã«ã¡ã¯ ðŸ‘‹"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0

      full_content = Enum.map_join(chunks, "", & &1.content)

      assert String.valid?(full_content)
    end
  end

  describe "stream integration patterns" do
    test "stream can be transformed with Stream functions" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Count to 3"
        })
        |> Ash.run_action()

      content_stream =
        stream
        |> Stream.map(fn chunk -> chunk.content end)
        |> Stream.filter(fn content -> String.length(content) > 0 end)

      contents = Enum.to_list(content_stream)
      assert Enum.all?(contents, &is_binary/1)
    end

    test "stream can be collected and processed" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello world"
        })
        |> Ash.run_action()

      all_chunks = Enum.to_list(stream)

      combined_content = Enum.map_join(all_chunks, "", & &1.content)

      assert is_binary(combined_content)
      assert String.length(combined_content) > 0
    end

    test "stream supports reduce operations" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Generate numbers"
        })
        |> Ash.run_action()

      chunk_count =
        stream
        |> Enum.reduce(0, fn _chunk, acc -> acc + 1 end)

      assert chunk_count > 0
    end
  end

  describe "stream error handling" do
    test "stream handles missing required arguments" do
      assert_raise Ash.Error.Invalid, fn ->
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{})
        |> Ash.run_action!()
      end
    end

    test "stream validates argument types" do
      assert_raise Ash.Error.Invalid, fn ->
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: 12_345
        })
        |> Ash.run_action!()
      end
    end

    @tag :skip
    test "stream handles API errors mid-stream" do
      # Note: This test is challenging to implement reliably because:
      # 1. We can't easily simulate mid-stream API errors without mocking
      # 2. OpenAI API is generally reliable and doesn't fail mid-stream often
      # 3. Network errors would require complex test infrastructure
      #
      # Instead, we verify that IF an error occurs during enumeration,
      # it propagates properly as an exception rather than hanging or crashing.
      #
      # For production confidence, we rely on:
      # - BamlElixir's error handling (tested in their library)
      # - Elixir Stream's natural error propagation
      # - Our other error handling tests (invalid args, timeouts)
      #
      # If you need to test this scenario specifically:
      # 1. Use a mock BAML client in test environment
      # 2. Inject errors after N chunks
      # 3. Verify error surfaces to caller
      #
      # Skipping this test as it requires mocking infrastructure that
      # doesn't exist yet. Consider adding mocking support if mid-stream
      # error handling becomes a production issue.

      flunk("Test requires mocking infrastructure - see comments for details")
    end
  end

  describe "streaming action generation" do
    test "stream action exists for imported function" do
      actions = Info.actions(AutoGeneratedTestResource)
      action_names = Enum.map(actions, & &1.name)

      # Stream action should exist
      assert :test_action_stream in action_names
    end

    test "stream action returns proper result structure" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Integration test"
        })
        |> Ash.run_action()

      stream_chunks = Enum.to_list(stream)

      # Should return Reply structs
      assert Enum.all?(stream_chunks, &match?(%BamlClient.Reply{}, &1))

      # Stream final chunk should have proper structure
      final_chunk = List.last(stream_chunks)
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
    end
  end
end
