defmodule AshBaml.StreamingIntegrationTest do
  use ExUnit.Case, async: false

  @moduletag :integration
  @moduletag timeout: 60_000

  alias Ash.Resource.Info
  alias AshBaml.Test.{AutoGeneratedTestResource, BamlClient, TestResource}

  setup do
    unless System.get_env("OPENAI_API_KEY") do
      flunk("OPENAI_API_KEY environment variable must be set for streaming integration tests")
    end

    :ok
  end

  describe "basic streaming functionality" do
    test "stream returns chunks as they arrive" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello and count to 5"
        })
        |> Ash.run_action()

      # Verify it's a Stream (Stream is a function, not a struct)
      assert is_function(stream)

      # Verify stream emits chunks
      chunks = Enum.to_list(stream)
      assert is_list(chunks)
      assert length(chunks) > 0

      # All chunks should be Reply structs
      assert Enum.all?(chunks, fn chunk ->
               match?(%BamlClient.Reply{}, chunk)
             end)
    end

    test "stream can be enumerated" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a very short poem"
        })
        |> Ash.run_action()

      # Test using Enum.each - collect chunks in agent
      {:ok, agent} = Agent.start_link(fn -> [] end)

      # Ensure cleanup even if test fails
      on_exit(fn ->
        if Process.alive?(agent), do: Agent.stop(agent)
      end)

      stream
      |> Enum.each(fn chunk ->
        Agent.update(agent, fn chunks -> [chunk | chunks] end)
      end)

      # Verify we collected chunks
      collected_chunks = Agent.get(agent, & &1)
      assert is_list(collected_chunks)
      assert length(collected_chunks) > 0

      # Cleanup will happen automatically via on_exit
    end

    test "stream completes with final result" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say 'test complete'"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      # Verify we got at least one chunk
      assert length(chunks) > 0

      # Last chunk should be the final result
      final_chunk = List.last(chunks)
      assert %BamlClient.Reply{} = final_chunk
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
    end

    test "stream can be consumed multiple times" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      # First enumeration
      first_chunks = Enum.to_list(stream)
      assert length(first_chunks) > 0

      # Second enumeration - this will create a new stream
      # Note: Streams are typically single-use, but we can get a new one
      {:ok, stream2} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      second_chunks = Enum.to_list(stream2)
      assert length(second_chunks) > 0

      # Both should have returned valid results
      assert Enum.all?(first_chunks, &match?(%BamlClient.Reply{}, &1))
      assert Enum.all?(second_chunks, &match?(%BamlClient.Reply{}, &1))
    end
  end

  describe "stream structure and types" do
    test "stream chunks have correct structure" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Generate a test response"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      # Verify we got at least one chunk
      assert length(chunks) > 0

      # Verify all chunks are Reply structs with content
      invalid_chunks =
        chunks
        |> Enum.reject(fn chunk ->
          match?(%BamlClient.Reply{content: content} when is_binary(content), chunk)
        end)

      assert invalid_chunks == [], "Found invalid chunks: #{inspect(invalid_chunks)}"

      # Final chunk should have both content and confidence
      final_chunk = List.last(chunks)
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
      assert final_chunk.confidence >= 0.0 and final_chunk.confidence <= 1.0
    end

    test "stream returns proper Elixir Stream" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Test"
        })
        |> Ash.run_action()

      # Verify it's a Stream (streams are functions)
      assert is_function(stream)

      # Verify it can be used with Stream functions
      mapped_stream =
        stream
        |> Stream.map(fn chunk -> chunk.content end)
        |> Stream.filter(fn content -> content != nil and content != "" end)

      # Stream.map returns a Stream struct
      assert match?(%Stream{}, mapped_stream)

      # Can still enumerate the mapped stream
      contents = Enum.to_list(mapped_stream)
      assert length(contents) > 0
      assert Enum.all?(contents, &is_binary/1)
    end
  end

  describe "auto-generated streaming actions" do
    test "import_functions creates working stream action" do
      # Verify the action exists
      actions = Info.actions(AutoGeneratedTestResource)
      stream_action = Enum.find(actions, fn action -> action.name == :test_action_stream end)

      assert stream_action != nil
      assert stream_action.type == :action

      # Verify it works
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Test auto-generated action"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0
      assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
    end

    test "stream action arguments match BAML function signature" do
      # Get the stream action
      actions = Info.actions(AutoGeneratedTestResource)
      stream_action = Enum.find(actions, fn action -> action.name == :test_action_stream end)

      # Verify arguments
      arguments = stream_action.arguments
      message_arg = Enum.find(arguments, fn arg -> arg.name == :message end)

      assert message_arg != nil
      # type is an Ash.Type module, not an atom
      assert message_arg.type == Ash.Type.String
      assert message_arg.allow_nil? == false
    end

    test "generated stream action name is correctly snake_cased" do
      # TestFunction -> test_function_stream
      actions = Info.actions(AutoGeneratedTestResource)
      action_names = Enum.map(actions, & &1.name)

      assert :test_action_stream in action_names
    end
  end

  describe "stream performance and concurrency" do
    test "stream handles early termination" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a very long story about a dragon"
        })
        |> Ash.run_action()

      # Take only first 3 chunks and stop early
      first_three = Enum.take(stream, 3)

      # Should have exactly 3 chunks
      assert length(first_three) == 3

      # All should be valid Reply structs
      assert Enum.all?(first_three, &match?(%BamlClient.Reply{}, &1))

      # The stream should have been terminated early without errors
      # (no assertion needed - if it doesn't crash, it works)
    end

    test "multiple concurrent streams work correctly" do
      # Start 3 concurrent streams
      tasks =
        for i <- 1..3 do
          Task.async(fn ->
            {:ok, stream} =
              TestResource
              |> Ash.ActionInput.for_action(:test_action_stream, %{
                message: "Count to #{i}"
              })
              |> Ash.run_action()

            chunks = Enum.to_list(stream)
            {i, chunks}
          end)
        end

      # Wait for all to complete
      results = Task.await_many(tasks, 30_000)

      # Verify all succeeded
      assert length(results) == 3

      Enum.each(results, fn {_i, chunks} ->
        assert length(chunks) > 0
        assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
      end)
    end

    test "stream completes in reasonable time" do
      start_time = System.monotonic_time(:millisecond)

      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello"
        })
        |> Ash.run_action()

      _chunks = Enum.to_list(stream)

      end_time = System.monotonic_time(:millisecond)
      duration = end_time - start_time

      # Should complete in under 10 seconds
      assert duration < 10_000
    end
  end

  describe "stream error resilience" do
    @tag :skip
    test "stream handles API errors mid-stream gracefully" do
      # Skipped: Requires mocking to inject errors reliably
      # Current implementation just hopes an error happens naturally
      flunk("Test skipped - requires error injection mocking")
    end

    @tag :skip
    test "stream raises exception on API errors" do
      # This test requires mocking BAML client to inject errors
      # Will be implemented when error injection is available
      # For now, skip to document expected behavior

      # Expected behavior:
      # - API error during streaming should raise exception
      # - Exception should be caught by Task
      # - Caller should receive {:error, exception} tuple
    end
  end

  describe "stream consistency" do
    test "stream final result matches non-streaming result" do
      message = "Say exactly: Hello from BAML"

      # Get non-streaming result
      {:ok, non_stream_result} =
        TestResource
        |> Ash.ActionInput.for_action(:test_function, %{
          message: message
        })
        |> Ash.run_action()

      # Get streaming result
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: message
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      final_chunk = List.last(chunks)

      # Both should be Reply structs
      assert %BamlClient.Reply{} = non_stream_result
      assert %BamlClient.Reply{} = final_chunk

      # Content should be similar (not necessarily identical due to LLM variance)
      # But both should contain the key phrase
      assert String.contains?(non_stream_result.content, "BAML") or
               String.contains?(non_stream_result.content, "Hello")

      assert String.contains?(final_chunk.content, "BAML") or
               String.contains?(final_chunk.content, "Hello")

      # Both should have valid confidence scores
      assert non_stream_result.confidence >= 0.0 and non_stream_result.confidence <= 1.0
      assert final_chunk.confidence >= 0.0 and final_chunk.confidence <= 1.0

      # Content structure should be similar
      assert is_binary(non_stream_result.content)
      assert is_binary(final_chunk.content)
      assert String.length(non_stream_result.content) > 0
      assert String.length(final_chunk.content) > 0
    end
  end

  describe "stream content variations" do
    test "stream with very long response" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Write a detailed description of how to bake a cake, including all steps"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)

      # Should have multiple chunks for long content
      assert length(chunks) > 0

      # Combine all content
      full_content = Enum.map_join(chunks, "", & &1.content)

      # Should be a substantial response
      assert String.length(full_content) > 50
    end

    test "stream with very short input" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Hi"
        })
        |> Ash.run_action()

      # Should still return valid chunks
      chunks = Enum.to_list(stream)
      assert is_list(chunks)
      assert length(chunks) > 0
    end

    test "stream with special characters" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say: Hello! ä½ å¥½ ðŸŒŸ @#$%"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0
      assert Enum.all?(chunks, &match?(%BamlClient.Reply{}, &1))
    end

    test "stream with unicode and emoji" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello in Japanese: ã“ã‚“ã«ã¡ã¯ ðŸ‘‹"
        })
        |> Ash.run_action()

      chunks = Enum.to_list(stream)
      assert length(chunks) > 0

      # Content should handle unicode properly
      full_content = Enum.map_join(chunks, "", & &1.content)

      assert String.valid?(full_content)
    end
  end

  describe "stream integration patterns" do
    test "stream can be transformed with Stream functions" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Count to 3"
        })
        |> Ash.run_action()

      # Transform stream to just get content
      content_stream =
        stream
        |> Stream.map(fn chunk -> chunk.content end)
        |> Stream.filter(fn content -> String.length(content) > 0 end)

      contents = Enum.to_list(content_stream)
      assert Enum.all?(contents, &is_binary/1)
    end

    test "stream can be collected and processed" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Say hello world"
        })
        |> Ash.run_action()

      # Collect all chunks
      all_chunks = Enum.to_list(stream)

      # Process collected chunks
      combined_content = Enum.map_join(all_chunks, "", & &1.content)

      assert is_binary(combined_content)
      assert String.length(combined_content) > 0
    end

    test "stream supports reduce operations" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Generate numbers"
        })
        |> Ash.run_action()

      # Use reduce to count chunks
      chunk_count =
        stream
        |> Enum.reduce(0, fn _chunk, acc -> acc + 1 end)

      assert chunk_count > 0
    end
  end

  describe "stream error handling" do
    test "stream handles missing required arguments" do
      assert_raise Ash.Error.Invalid, fn ->
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{})
        |> Ash.run_action!()
      end
    end

    test "stream validates argument types" do
      # Passing wrong type should fail
      assert_raise Ash.Error.Invalid, fn ->
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          # Should be string
          message: 12_345
        })
        |> Ash.run_action!()
      end
    end

    @tag :skip
    test "stream handles API errors mid-stream" do
      # Note: This test is challenging to implement reliably because:
      # 1. We can't easily simulate mid-stream API errors without mocking
      # 2. OpenAI API is generally reliable and doesn't fail mid-stream often
      # 3. Network errors would require complex test infrastructure
      #
      # Instead, we verify that IF an error occurs during enumeration,
      # it propagates properly as an exception rather than hanging or crashing.
      #
      # For production confidence, we rely on:
      # - BamlElixir's error handling (tested in their library)
      # - Elixir Stream's natural error propagation
      # - Our other error handling tests (invalid args, timeouts)
      #
      # If you need to test this scenario specifically:
      # 1. Use a mock BAML client in test environment
      # 2. Inject errors after N chunks
      # 3. Verify error surfaces to caller
      #
      # Skipping this test as it requires mocking infrastructure that
      # doesn't exist yet. Consider adding mocking support if mid-stream
      # error handling becomes a production issue.

      flunk("Test requires mocking infrastructure - see comments for details")
    end
  end

  describe "streaming action generation" do
    test "stream action exists for imported function" do
      actions = Info.actions(AutoGeneratedTestResource)
      action_names = Enum.map(actions, & &1.name)

      # Stream action should exist
      assert :test_action_stream in action_names
    end

    test "stream action returns proper result structure" do
      {:ok, stream} =
        TestResource
        |> Ash.ActionInput.for_action(:test_action_stream, %{
          message: "Integration test"
        })
        |> Ash.run_action()

      stream_chunks = Enum.to_list(stream)

      # Should return Reply structs
      assert Enum.all?(stream_chunks, &match?(%BamlClient.Reply{}, &1))

      # Stream final chunk should have proper structure
      final_chunk = List.last(stream_chunks)
      assert is_binary(final_chunk.content)
      assert is_float(final_chunk.confidence)
    end
  end
end
