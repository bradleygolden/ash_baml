defmodule AshBaml.AutoGeneratedActionsTest do
  use ExUnit.Case, async: true

  alias Ash.Resource.Info
  alias AshBaml.Actions.CallBamlFunction
  alias AshBaml.Actions.CallBamlStream
  alias AshBaml.FunctionIntrospector
  alias AshBaml.Test.AutoGeneratedTestResource
  alias AshBaml.Test.BamlClient
  alias AshBaml.Type.Stream

  describe "auto-generated regular actions" do
    test "test_function action exists" do
      action = Info.action(AutoGeneratedTestResource, :test_function)

      assert action != nil
      assert action.type == :action
      assert action.description =~ "Auto-generated from BAML function TestFunction"
    end

    test "test_function has correct arguments" do
      action = Info.action(AutoGeneratedTestResource, :test_function)

      assert length(action.arguments) == 1
      arg = Enum.find(action.arguments, &(&1.name == :message))
      assert arg != nil
      assert arg.type == Ash.Type.String
      assert arg.allow_nil? == false
    end

    test "test_function has correct return type" do
      action = Info.action(AutoGeneratedTestResource, :test_function)

      # The return type should be the Reply module from Types namespace
      assert action.returns == BamlClient.Types.Reply
    end

    test "test_function uses correct implementation" do
      action = Info.action(AutoGeneratedTestResource, :test_function)

      assert action.run == {CallBamlFunction, [function: :TestFunction]}
    end
  end

  describe "auto-generated streaming actions" do
    test "test_function_stream action exists" do
      action = Info.action(AutoGeneratedTestResource, :test_function_stream)

      assert action != nil
      assert action.type == :action
      assert action.description =~ "Auto-generated from BAML function TestFunction"
    end

    test "test_function_stream has correct return type" do
      action = Info.action(AutoGeneratedTestResource, :test_function_stream)

      assert action.returns == Stream
    end

    test "test_function_stream has correct constraints" do
      action = Info.action(AutoGeneratedTestResource, :test_function_stream)

      assert action.constraints[:element_type] == BamlClient.Types.Reply
    end

    test "test_function_stream uses correct implementation" do
      action = Info.action(AutoGeneratedTestResource, :test_function_stream)

      assert action.run == {CallBamlStream, [function: :TestFunction]}
    end

    test "test_function_stream has same arguments as regular action" do
      regular_action = Info.action(AutoGeneratedTestResource, :test_function)
      stream_action = Info.action(AutoGeneratedTestResource, :test_function_stream)

      assert length(regular_action.arguments) == length(stream_action.arguments)

      Enum.zip(regular_action.arguments, stream_action.arguments)
      |> Enum.each(fn {reg_arg, stream_arg} ->
        assert reg_arg.name == stream_arg.name
        assert reg_arg.type == stream_arg.type
        assert reg_arg.allow_nil? == stream_arg.allow_nil?
      end)
    end
  end

  describe "action naming conversion" do
    test "converts PascalCase to snake_case" do
      action = Info.action(AutoGeneratedTestResource, :test_function)
      assert action != nil

      stream_action = Info.action(AutoGeneratedTestResource, :test_function_stream)
      assert stream_action != nil
    end
  end

  describe "compile-time validation" do
    test "provides helpful error for missing function" do
      error =
        FunctionIntrospector.validate_function_exists(
          BamlClient,
          :NonExistentFunction
        )

      assert {:error, message} = error
      assert message =~ "not found"
      assert message =~ "Available functions"
    end
  end
end
